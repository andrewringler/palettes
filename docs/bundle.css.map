{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../Icon.html",
    "../App.svelte",
    "../ButtonGroup.svelte",
    "../Card.svelte",
    "../Color.svelte",
    "../ColorBlindCheck.svelte",
    "../ColorList.svelte",
    "../ColorListReadOnly.svelte",
    "../DerivedColorList.svelte",
    "../Export.svelte",
    "../PalettePreview.svelte",
    "../StepChart.svelte",
    "../StepChart2.svelte"
  ],
  "sourcesContent": [
    "<svg\r\n  aria-hidden=\"true\"\r\n  class=\"{classes}\"\r\n  role=\"img\"\r\n  xmlns=\"http://www.w3.org/2000/svg\"\r\n  viewBox=\"{viewBox}\"\r\n>\r\n  <path fill=\"currentColor\" d=\"{path}\" />\r\n</svg>\r\n<script>\r\n  export let icon;\r\n\r\n  let path = [];\r\n  let classes = \"\";\r\n  let viewBox = \"\";\r\n\r\n  $: viewBox = \"0 0 \" + icon.icon[0] + \" \" + icon.icon[1];\r\n\r\n  $: classes = \"fa-svelte \" + ($$props.class ? $$props.class : \"\");\r\n\r\n  $: path = icon.icon[4];\r\n</script>\r\n\r\n<style>\r\n  .fa-svelte {\r\n    width: 1em;\r\n    height: 1em;\r\n    overflow: visible;\r\n    display: inline-block;\r\n  }\r\n</style>",
    "<script>\n    import chroma from 'chroma-js';\n    import { beforeUpdate, onMount } from 'svelte';\n    import Checkbox from './Checkbox.svelte';\n    import InputColors from './InputColors.svelte';\n    import PalettePreview from './PalettePreview.svelte';\n    import Export from './Export.svelte';\n    import StepChart from './StepChart.svelte';\n    import StepChart2 from './StepChart2.svelte';\n    import Card from './Card.svelte';\n    import ColorBlindCheck from './ColorBlindCheck.svelte';\n    import ButtonGroup from './ButtonGroup.svelte';\n    import ColorListReadOnly from './ColorListReadOnly.svelte';\n    import DerivedColorList from './DerivedColorList.svelte';\n    import { compactColorRulesString, compactColorRulesStringToColorRules } from './colorUtils';\n\n    export let name;\n\n    let steps = [];\n    let bezier = true;\n    let correctLightness = true;\n    let generateSecondaryColors = false;\n\n    let colors = '00429d,96ffea,lightyellow'.split(/\\s*,\\s*/).map(c => chroma(c));\n    let colors2 = [];\n    let numColors = 9;\n    let mode = 'sequential';\n    let arrangeBy = 'manual';\n    let simulate = 'none';\n    let secondaryColorRules = [];\n\n    if (window.location.hash) {\n        readStateFromHash();\n    }\n\n    $: hash = [\n        numColors,\n        mode.substr(0,1),\n        colors.map(c=>c.hex().substr(1)).join(','),\n        colors2.length ? colors2.map(c=>c.hex().substr(1)).join(',') : '',\n        correctLightness ? 1:0,\n        bezier ? 1:0,\n        generateSecondaryColors ? 1:0,\n        secondaryColorRules.length && generateSecondaryColors ? compactColorRulesString(secondaryColorRules) : ''\n    ].join('|');\n\n    $: bezierDisabled = (mode==='sequential' || mode==='manual') ? !(colors.length>1&&colors.length<=5) : !(colors2.length>1&&colors2.length<=5 || colors.length>1&&colors.length<=5);\n    $: generateColorsDisabled = mode==='manual';\n    $: numOutputColors = generateColorsDisabled ? colors.length : numColors;\n    $: colors, arrangeBy, arrangeColors();\n    $: outputColors = steps.map(step => chroma(step))\n\n    $: outputColors, updateSecondaryColorRules()\n\n    const isMac = navigator.platform.toUpperCase().indexOf('MAC') > -1;\n\n    let _hash = '';\n    let _mounted = false;\n    let _mode = 'sequential';\n\n    beforeUpdate(() => {\n        if (hash !== _hash) {\n            _hash = hash;\n            window.location.hash = `#/${hash}`;\n        }\n        if (mode !== _mode) {\n            if (mode === 'diverging' && !colors2.length) {\n                colors2 = colors.slice(0).reverse();\n            }\n            if (mode === 'sequential' || mode === 'manual') {\n                colors2 = [];\n            }\n            _mode = mode;\n        }\n    });\n\n    // onMount(() => {\n    //     if (window.location.hash) {\n    //         console.log('initial hash', window.location.hash);\n    //         readStateFromHash();\n    //     }\n    //     _mounted = true;\n// })\n\n    function arrangeColors() {\n        if(arrangeBy === 'manual' || mode === 'diverging') {\n            return\n        }\n\n        setTimeout(() => {\n            let colorsOld = [...colors];\n\n            if(arrangeBy === 'lightness') {\n                colors = colors.sort((a, b) => a.lch()[0] > b.lch()[0] ? 1 : -1)                \n            }\n            if(arrangeBy === 'chroma') {\n                colors = colors.sort((a, b) => a.lch()[1] > b.lch()[1] ? 1 : -1)\n            }\n            if(arrangeBy === 'hue') {\n                colors = colors.sort((a, b) => a.lch()[2] > b.lch()[2] ? 1 : -1)\n            }\n\n            // sort color rules by same metric, if lengths match\n            if(colors.length === secondaryColorRules.length) {\n                let sortOrder = colorsOld.map(oldColor => {\n                    return colors.indexOf(oldColor);\n                })\n                let newSecondaryColorRules = [...secondaryColorRules];\n                secondaryColorRules.forEach((rule, idx) => {\n                    newSecondaryColorRules[sortOrder[idx]] = rule;\n                })\n                secondaryColorRules = newSecondaryColorRules;\n            }\n        }, 150)\n    }\n\n    function updateSecondaryColorRules() {\n        if(secondaryColorRules.length === outputColors.length) {\n            return; // all set\n        }\n\n        // Create new arrays of correct size filled with default rules\n        let newSecondaryColorsRules = [];\n        for(var i=0; i<outputColors.length; i++) {\n            let rules = [];\n            let numberOfColors = 3;\n            if(Array.isArray(secondaryColorRules) && secondaryColorRules.length > i) {\n                numberOfColors = secondaryColorRules[i].length;\n            }\n            for(var j=0; j<numberOfColors; j++) {\n                let offset = (j+1)*1.1 / 10.0;\n                rules.push({ l: (1 + offset).toFixed(1), c: (1 + offset/2.0).toFixed(1), h: 1 });\n            }\n            newSecondaryColorsRules.push(rules)\n        }\n\n        // Fill in any any existing old rules that have the same indices\n        if(Array.isArray(secondaryColorRules)) {\n            for(var i=0; i<outputColors.length; i++) {\n                let rules = newSecondaryColorsRules[i];\n                for(var j=0; j<rules.length; j++) {\n                    let oldRule = secondaryColorRules.length > i && Array.isArray(secondaryColorRules[i]) && secondaryColorRules[i].length > j && secondaryColorRules[i][j]\n                    if(typeof oldRules === 'object') {\n                        rules[j] = oldRule;\n                    }\n                }\n            }    \n        }\n\n        setTimeout(() => {\n            secondaryColorRules = newSecondaryColorsRules;\n        }, 150)\n    }\n\n    function readStateFromHash() {\n        const parts = window.location.hash.substr(2).split('|');\n        if (parts.length >= 6) {\n            setTimeout(() => {\n                numColors = +parts[0];\n                mode = parts[1] === 's' ? 'sequential' : (parts[1] === 'd' ? 'diverging' : 'manual');\n                _mode = mode;\n                colors = parts[2].split(',').map(c => c && chroma(c));\n                colors2 = parts[3] !== '' ? parts[3].split(',').map(c => c && chroma(c)) : [];\n                correctLightness = parts[4] === '1';\n                bezier = parts[5] === '1';\n                generateSecondaryColors = parts.length >= 7 && parts[6] === '1';\n                if(parts.length >= 8) {\n                    secondaryColorRules = compactColorRulesStringToColorRules(parts[7]);\n                }\n            }, 150);\n        } else {\n            window.location.hash = '';\n        }\n    }\n\n    function hashChange() {\n        if (window.location.hash !== `#/${hash}`) {\n            // deserialize hash\n            readStateFromHash();\n        }\n    }\n</script>\n\n<style>\n    .head {\n        margin: 1em 0 1em;\n    }\n    h1 {\n    }\n    .warning {\n      font-size: 0.8em;\n      color: orange;\n      font-weight: bold;\n      display: block;\n    }\n    select.custom-select {\n        display: inline-block;\n        width: auto;\n        font-size: inherit;\n        padding: 0.4em 1.7em 0.4em 0.4em;\n        margin: 0px 0.7ex 5px;\n    }\n    input[type=number] {\n        width: 4em;\n        text-align: center;\n        margin: 0px 0.7ex 5px;\n    }\n    .foot {\n        margin-bottom: 1em;\n    }\n    :global(.fa-svelte) {\n        vertical-align: sub;\n    }\n    kbd\n    {\n        -moz-border-radius:3px;\n        -moz-box-shadow:0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;\n        -webkit-border-radius:3px;\n        -webkit-box-shadow:0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;\n        background-color:#f7f7f7;\n        border:1px solid #ccc;\n        border-radius:3px;\n        box-shadow:0 1px 0 rgba(0,0,0,0.2),0 0 0 2px #fff inset;\n        color:#333;\n        display:inline-block;\n        /*font-family:Arial,Helvetica,sans-serif;*/\n        line-height:1.4;\n        margin:0 .1em;\n        padding:.1em .6em;\n        text-shadow:0 1px 0 #fff;\n    }\n    .text-muted {\n        font-size: 0.85rem;\n        display: inline-block;\n        padding-top: 6px;\n    }\n    .arrange-inputs {\n        margin-top: 1rem;\n    }\n</style>\n\n<svelte:window on:hashchange={hashChange} />\n\n<div class=\"container\">\n    <div class=\"head\">\n        <h1>Data Color Palettes</h1>\n        <p>This tools aids in generating perceptually meaningful and vision accessible color palettes for use in data visualization. Create sequential, <a target=\"_blank\" href=\"http://vis4.net/blog/posts/mastering-multi-hued-color-scales/\">multi-hued & multi-stop diverging</a> and qualitative color schemes.</p>\n    </div>\n    <Card step=\"1\" title=\"What kind of palette do you want to create?\">\n        <div class=\"row\">\n            <div class=\"col-md\">\n                Palette type:\n                <ButtonGroup options=\"{['sequential', 'diverging', 'manual']}\" bind:value={mode} />\n            </div>\n            {#if generateColorsDisabled}\n                <div class=\"col-md\">\n                    Number of colors: <input type=\"number\" min=\"2\" bind:value={numOutputColors} disabled />\n                </div>\n            {:else}\n                <div class=\"col-md\">\n                    Number of colors: <input type=\"number\" min=\"2\" bind:value={numColors} />\n                </div>\n            {/if}\n        </div>\n    </Card>\n\n    <Card step=\"2\" title=\"Select and arrange input colors\">\n        <InputColors diverging=\"{mode==='diverging'}\" bind:colors bind:colors2 />\n            <div class=\"arrange-inputs\">\n                <span class=\"text-muted\">Arrange by:</span> <ButtonGroup buttonSmall=\"{true}\" options=\"{['manual', 'lightness', 'chroma', 'hue']}\" bind:value={arrangeBy} />\n            </div>\n    </Card>\n\n    <Card step=\"3\" title=\"Check and configure the resulting palette\">\n        <div class=\"row\" style=\"margin-bottom: 10px\">\n            <div class=\"col-md\">\n                <Checkbox bind:value={correctLightness} label=\"correct lightness\" />\n                <Checkbox bind:value={bezier} label=\"bezier interpolation\" disabled={bezierDisabled} />\n                {#if bezierDisabled}\n                <span class=\"warning\">* Bezier interpolation requires 2-5 input colors</span>\n                {/if}\n            </div>\n            <div class=\"col-md\">\n                <ColorBlindCheck bind:colors={steps} bind:active={simulate} />\n            </div>\n        </div>\n        <PalettePreview\n            bind:steps\n            bind:correctLightness\n            bind:bezier\n            bind:colors\n            bind:colors2\n            diverging=\"{mode === 'diverging'}\"\n            simulate={simulate}\n            bind:numColors={numOutputColors} />\n         <div class=\"row\" style=\"margin: 10px 0 10px 0\">\n            <ColorListReadOnly bind:colors={outputColors} />\n        </div>\n        <div class=\"row\">\n            <div class=\"col-md\">\n                <StepChart title=\"lightness (LCH)\" steps={steps} mode={0} />\n            </div>\n            <div class=\"col-md\">\n                <StepChart title=\"chroma (LCH)\" steps={steps} mode={1} />\n            </div>\n            <div class=\"col-md\">\n                <StepChart title=\"hue (LCH)\" steps={steps} mode={2} />\n            </div>\n            <div class=\"col-md\">\n                <StepChart title=\"saturation (HSL)\" steps={steps} mode={3} />\n            </div>\n        </div>\n    </Card>\n\n    <Card step=\"4\" title=\"Generate Secondary Palette Colors\">\n        <div>\n            <Checkbox bind:value={generateSecondaryColors} label=\"generate secondary colors\" />\n        </div>\n        {#if generateSecondaryColors}\n            {#each outputColors as baseColor, i}\n                <div class=\"row\" style=\"margin: 10px 0 10px 0\">\n                    <DerivedColorList baseColor={baseColor} index={i} bind:allColorRules={secondaryColorRules} />\n                </div>\n            {/each}\n\n            {#if Array.isArray(secondaryColorRules)}\n            <div class=\"row\">\n                <div class=\"col-md\">\n                    <StepChart2 title=\"% change lightness (LCH)\" values={secondaryColorRules} field=\"l\" colors={outputColors} />\n                </div>\n                <div class=\"col-md\">\n                    <StepChart2 title=\"% change chroma (LCH)\" values={secondaryColorRules} field=\"c\" colors={outputColors} />\n                </div>\n                <div class=\"col-md\">\n                    <StepChart2 title=\"% change hue (LCH)\" values={secondaryColorRules} field=\"h\" colors={outputColors} />\n                </div>\n            </div>\n            {/if}\n        {/if}\n    </Card>\n\n    <Card step=\"5\" title=\"Export the color codes in various formats\">\n        <p>You can also save your palette for later by bookmarking <a href=\"#/{hash}\">this page</a> using <kbd>{isMac ? 'cmd' : 'ctrl'}</kbd>+<kbd>d</kbd>.</p>\n        <Export steps={steps} />\n    </Card>\n\n    <div class=\"foot\">\n        <hr>\n        <p>Check it out <a href=\"https://github.com/andrewringler/palettes\">on Github</a></p>\n        <p>Adpated by <a href=\"https://andrewringler.com/\">Andrew Ringler</a> from <a href=\"https://github.com/gka/palettes\">palettes</a>, originally created by <a href=\"https://vis4.net/blog\">Gregor Aisch</a>.</p>\n    </div>\n</div>\n",
    "<script>\n\texport let options = [];\n\t$: options2 = options.map(s => typeof s === 'string' ? {value:s, title:s} : s);\n\texport let value;\n\texport let label = '';\n\tconst id = Math.round(Math.random()*1e7).toString(36);\n\texport let buttonSmall = false;\n</script>\n\n<style>\n\t.btn-group {\n\t\tposition: relative;\n\t\ttop: -4px;\n\t\tpadding-left:1ex;\n\t\tpadding-right:1ex;\n\t}\n</style>\n\n<div class=\"btn-group btn-group-toggle\" data-toggle=\"buttons\">\n    {#each options2 as option}\n    <label class=\"btn btn-outline-secondary {buttonSmall ? 'btn-sm' : ''}\"\n        class:active={value===option.value}>\n        <input bind:group={value} value=\"{option.value}\" type=\"radio\" name=\"options\" id=\"{id}\" autocomplete=\"off\" checked={value===option.value}>{option.title}\n    </label>\n    {/each}\n</div>",
    "<script>\n\texport let title = '';\n\texport let step = '';\n\texport let noBorderTop = false;\n</script>\n\n<style>\n\t.card {\n\t\tmargin-bottom: 20px;\n\t}\n\tspan.step {\n\t\tdisplay: inline-block;\n\t\tbackground: #f3f3f3;\n\t\tborder: 1px solid #ddd;\n\t\tcolor: #bbb;\n\t\twidth: 1.5em;\n\t\theight: 1.5em;\n\t\tline-height: 1.5em;\n\t\ttext-align: center;\n\t\tmargin-right: 1ex;\n\t\tfont-size: 1.35rem;\n\t}\n</style>\n\n<div class:rounded-0={noBorderTop} class:border-top-0={noBorderTop} class=\"card shadow-sm\">\n\t<div class=\"card-body\">\n\t\t<h5 class=\"card-title\">{#if step}<span class=\"step rounded-circle\">{step}</span>{/if}{title}</h5>\n\t\t<slot />\n\t</div>\n</div>\n",
    "<script>\n    import chroma from 'chroma-js';\n    import range from 'lodash-es/range';\n    export let value = chroma('red');\n    export let readOnly = false\n\n    let open = false;\n    let dragging = false;\n\n    function toggleEditOpen() { open = readOnly ? false : true; }\n    function toggleEditClose() { open = false; }\n\n    let colorName;\n\n    $: lch = value.lch()\n    $: lightness = range(-5,6)\n        .map(l => lch[0] + Math.pow(l/8,2)*80*(l<0?-1:1))\n        .map(l => chroma.lch(l, lch[1], lch[2]));\n    $: saturation = range(-5,6)\n        .map(s => Math.max(0, lch[1] + Math.pow(s/5,2)*80*(s<0?-1:1)))\n        .map(s => chroma.lch(lch[0], s, lch[2]));\n    $: hue = range(-5,6)\n        .map(h => lch[2] + Math.pow(h/5,2)*80*(h<0?-1:1))\n        .map(h => chroma.lch(lch[0], lch[1], h < 0 ? h + 360 : h > 360 ? h - 360 : h));\n</script>\n\n<style>\n    span.badge {\n        font-weight: normal;\n        font-size: 100%;\n        color: #000;\n        position: relative;\n    }\n    .badge + .badge {\n        margin-left: 1ex;\n\n    }\n    span.inverted {\n        color: white;\n    }\n    .popover {\n        position: absolute;\n        top: 30px;\n        left: -100px;\n        width: 300px;\n    }\n    .color-row {\n        display: flex;\n        margin-bottom: 3px;\n    }\n    span.lbl {\n        width: 8.333%\n    }\n    span.color {\n        display: inline-block;\n        height: 30px;\n        width: 8.333%;\n        border-left: 1px solid white;\n        border-bottom: 1px solid white;\n    }\n    span.color:nth-child(7) {\n        border: 2px solid black;\n        margin-top:-1px;\n        margin-right: 0px;\n        height: 31px;\n    }\n    span.color:nth-child(8) {\n        border-left: 0;\n    }\n    span.hex {\n        pointer-events: none;\n    }\n</style>\n<span\n    on:dragstart\n    on:dragstart=\"{(event) => dragging = readOnly ? false : true}\"\n    on:dragend=\"{(event) => dragging = false, open = false}\"\n    draggable=\"true\"\n    on:mouseenter={toggleEditOpen}\n    on:mouseleave={toggleEditClose}\n    on:click|stopPropagation=\"{() => false}\"\n    class:inverted={value.lab()[0]<50}\n    class=\"badge shadow-sm\"\n    style=\"background: {value.hex()}\">\n    <span class=\"hex\">{value.hex().substr(1)}</span>\n    {#if open && !dragging}\n    <div style=\"position: absolute;top:0px;left:0;right:0;height: 40px\">\n        <div\n            class=\"popover fade show bs-popover-bottom\"\n            role=\"tooltip\" x-placement=\"bottom\">\n            <div class=\"arrow\" style=\"left: 121px;\"></div>\n            <h3 class=\"popover-header\"></h3>\n            <div class=\"popover-body\">\n                <div class=\"color-row\">\n                    <span class=\"lbl\">L</span>\n                    {#each lightness as l}\n                    <span on:click=\"{() => value = l}\" class=\"color\" style=\"background: {l.hex()}\"></span>\n                    {/each}\n                </div>\n                <div class=\"color-row\">\n                    <span class=\"lbl\">S</span>\n                    {#each saturation as c}\n                    <span on:click=\"{() => value = c}\" class=\"color\" style=\"background: {c.hex()}\"></span>\n                    {/each}\n                </div>\n                <div class=\"color-row\">\n                    <span class=\"lbl\">H</span>\n                    {#each hue as c}\n                    <span on:click=\"{() => value = c}\" class=\"color\" style=\"background: {c.hex()}\"></span>\n                    {/each}\n                </div>\n            </div>\n        </div>\n    </div>\n    {/if}\n</span>\n\n",
    "<script>\n    import Icon from 'fa-svelte';\n    import { faCheck } from '@fortawesome/free-solid-svg-icons/faCheck';\n    import { faExclamationTriangle } from '@fortawesome/free-solid-svg-icons/faExclamationTriangle';\n    import { colorBlindCheck } from'./colorBlind';\n\n    $: result = colorBlindCheck(colors);\n\n    export let colors = [];\n    export let result = [];\n\n    export let active = 'none';\n\n    const types = ['none', 'deuteranopia', 'protanopia', 'tritanopia'];\n</script>\n\n<style>\n\n@media (min-width: 720px) {\n    .colorblind-sim {\n        text-align: right;\n        position: absolute;\n        right: 20px;\n        top: -46px;\n    }\n    .res {\n        text-align: right;\n    }\n}\n.text-muted {\n    padding-right: 1em;\n    font-size: 0.85rem;\n    display: inline-block;\n    padding-top: 6px;\n}\n.c1 {\n    margin-top: -15px;\n}\n\n</style>\n\n\n<div class=\"colorblind-sim\">\n    {#if result.length}\n    <p class=\"res text-danger\"><Icon icon={faExclamationTriangle} /> This palette is not colorblind-safe.</p>\n    {:else}\n    <p class=\"res text-secondary\"><Icon icon={faCheck} /> This palette is colorblind-safe.</p>\n    {/if}\n    <div class=\"c1\">\n        <div class=\"text-muted\">simulate:</div>\n        <div class=\"btn-group btn-group-toggle\" data-toggle=\"buttons\">\n            {#each types as type}\n            <label class=\"btn btn-sm btn-outline-secondary\"\n                class:btn-outline-danger=\"{result.indexOf(type) > -1}\"\n                class:active={active===type}>\n                <input bind:group={active} value=\"{type}\" type=\"radio\" name=\"options\" id=\"option1\" autocomplete=\"off\" checked={active===type}>{type === 'none' ? 'normal' : type.substr(0,4)+'.'}\n            </label>\n            {/each}\n        </div>\n    </div>\n</div>\n",
    "<script>\n    import chroma from 'chroma-js';\n    import Color from './Color.svelte';\n\n    export let colors;\n    let edit = false;\n    let input;\n\n    let colorString = '';\n\n    function enterEditMode() {\n        edit = true;\n        colorString = colors.map(c => c.name()).join(', ');\n        input.focus();\n    }\n\n    function exitEditMode() {\n        edit = false;\n        colors = colorString\n            .split(/\\s*[,|\\s]\\s*/)\n            .filter(c => chroma.valid(c))\n            .map(c => chroma(c));\n    }\n\n    function dragstart(event, index) {\n        event.dataTransfer.setData('index', index);\n    }\n\n    function dragover(event) {\n        event.dataTransfer.dropEffect = 'move';\n    }\n\n    function drop(event) {\n        const index = event.dataTransfer.getData('index');\n        const newIndex = findIndex(event.target);\n        const col = colors.splice(index, 1, null)[0];\n        colors.splice(newIndex, 0, col);\n        colors = colors.filter(c => c !== null);\n    }\n\n    function findIndex(el) {\n        const siblings = el.parentNode.children;\n        for (let i=0; i<siblings.length; i++) {\n            if (siblings[i] === el) return i;\n        }\n        return -1;\n    }\n</script>\n\n<style>\n    div.form-control {\n        cursor: text;\n        height: auto;\n    }\n    .hidden {\n        position: absolute;\n        opacity: 0;\n        left: -99999px;\n    }\n    span.inv {\n        display: inline-block;\n        width: 60px;\n        background: white;\n        height: 100%;\n        vertical-align: bottom;\n    }\n</style>\n\n<input class:hidden={!edit} bind:this={input} type=\"text\" class=\"form-control\" bind:value={colorString} on:blur={exitEditMode}>\n{#if !edit}\n<div\n    on:drop|preventDefault=\"{(event) => drop(event)}\"\n    on:dragover|preventDefault=\"{(event) => dragover(event)}\"\n    class=\"form-control\"\n    on:click={enterEditMode}>\n    {#each colors as color,i}\n    <Color\n        bind:value={color}\n        on:dragstart=\"{(event) => dragstart(event, i)}\" />\n    {/each}\n    <span class=\"inv\"></span>\n</div>\n{/if}",
    "<script>\n    import chroma from 'chroma-js';\n    import Color from './Color.svelte';\n\n    export let colors;\n</script>\n\n<style>\n    div.form-control {\n        height: auto;\n    }\n    span.inv {\n        display: inline-block;\n        width: 60px;\n        background: white;\n        height: 100%;\n        vertical-align: bottom;\n    }\n</style>\n\n<div class=\"form-control\">\n    {#each colors as color,i}\n    <Color bind:value={color} readOnly={true} />\n    {/each}\n    <span class=\"inv\"></span>\n</div>",
    "<script>\n    import chroma from 'chroma-js';\n    import Color from './Color.svelte';\n    import { generateDerivedColors, DECIMAL_PLACES, lchPctRegex, colorModifierObjectToString } from './colorUtils';\n\n    export let index;\n    export let allColorRules;\n    export let baseColor;\n    $: colorRules = allColorRules[index]\n    $: colors = generateDerivedColors(baseColor, colorRules)\n    $: baseColor, colorRules, generateDerivedColors(baseColor, colorRules)\n    \n    let edit = false;\n    let input;\n\n    let colorString = '';\n\n    function enterEditMode() {\n        edit = true;\n        colorString = colorRules.map(colorModifierObjectToString).join(', ');\n        input.focus();\n    }\n\n    function stringToRule(s) {\n        // LCH Percentage Modifier\n        let modifiers = lchPctRegex.exec(s)\n        if(modifiers && modifiers.length === 4) {\n            let lch = { \n                l: (parseFloat(modifiers[1])/100.0).toFixed(DECIMAL_PLACES),\n                c: (parseFloat(modifiers[2])/100.0).toFixed(DECIMAL_PLACES),\n                h: (parseFloat(modifiers[3])/100.0).toFixed(DECIMAL_PLACES)\n            }\n            return lch\n        }\n\n        // Valid Color Entered Directly? convert it to a LCH percentage Modifier\n        if(chroma.valid(s)) {\n            let derivedColor = chroma(s);\n            let derivedColorLCH = derivedColor.lch();\n            let baseColorLCH = baseColor.lch();\n\n            let lch = { \n                l: (derivedColorLCH[0]/baseColorLCH[0]).toFixed(DECIMAL_PLACES), \n                c: (derivedColorLCH[1]/baseColorLCH[1]).toFixed(DECIMAL_PLACES),\n                h: (derivedColorLCH[2]/baseColorLCH[2]).toFixed(DECIMAL_PLACES)\n            }\n            return lch;\n        }\n\n        return undefined;\n    }\n\n    function exitEditMode() {\n        edit = false;\n\n        let newRules = colorString.split(/\\s*[,|\\s]\\s*/).map(stringToRule).filter(r => r)\n\n        setTimeout(() => {\n            allColorRules[index] = newRules;\n        }, 150)\n    }\n\n    function dragstart(event, index) {\n        event.dataTransfer.setData('index', index);\n    }\n\n    function dragover(event) {\n        event.dataTransfer.dropEffect = 'move';\n    }\n\n    function drop(event) {\n        const index = event.dataTransfer.getData('index');\n        const newIndex = findIndex(event.target);\n        const col = colors.splice(index, 1, null)[0];\n        colors.splice(newIndex, 0, col);\n        colors = colors.filter(c => c !== null);\n    }\n\n    function findIndex(el) {\n        const siblings = el.parentNode.children;\n        for (let i=0; i<siblings.length; i++) {\n            if (siblings[i] === el) return i;\n        }\n        return -1;\n    }\n</script>\n\n<style>\n    div.form-control {\n        cursor: text;\n        height: auto;\n    }\n    .hidden {\n        position: absolute;\n        opacity: 0;\n        left: -99999px;\n    }\n    span.inv {\n        display: inline-block;\n        width: 60px;\n        background: white;\n        height: 100%;\n        vertical-align: bottom;\n    }\n    .palette {\n        background: #eee;\n        padding: 10px;\n        display: flex;\n        height: 100px;\n        width: 100%;\n        margin-bottom: 10;\n    }\n    .step {\n       height: 100%;\n       display: block;\n       flex-grow: 1;\n    }\n</style>\n\n<div class=\"palette\" style=\"margin-bottom: 10px\">\n    {#each colors as color}\n    <div class=\"step\" style=\"background-color: {color.hex()}\"></div>\n    {/each}\n</div>\n\n<input class:hidden={!edit} bind:this={input} type=\"text\" class=\"form-control\" bind:value={colorString} on:blur={exitEditMode}>\n{#if !edit}\n<div\n    class=\"form-control\"\n    on:click={enterEditMode}>\n    {#each colors as color,i}\n        <Color bind:value={color} />\n    {/each}\n    <span class=\"inv\"></span>\n</div>\n{/if}",
    "<script>\n    export let steps = [];\n</script>\n\n<style>\n    pre {\n        padding: 1ex;\n        background: #eee;\n        white-space: pre-wrap;\n    }\n</style>\n\n<pre>{steps}</pre>\n<pre>'{steps.join(`', '`)}'</pre>\n<pre>['{steps.join(`', '`)}']</pre>\n<pre>{steps.join('\\n')}</pre>\n<pre>[{steps.map(c => '0x'+c.substr(1)).join(`,`)}]</pre>\n<pre>\nimport &#123; scaleThreshold &#125; from 'd3-scale';\n\nfunction palette(min, max) &#123;\n    const d = (max-min)/{steps.length};\n    return scaleThreshold()\n        .range(['{steps.join(`', '`)}'])\n        .domain([{steps.slice(1).map((v,i) => `min + d*${i+1}`)}]);\n&#125;\n</pre>",
    "<script>\n    import chroma from 'chroma-js';\n    import { colorBlindSim } from'./colorBlind';\n    import _range from 'lodash-es/range';\n\n    export let colors = ['red']\n    export let colors2 = [];\n    export let numColors = 7;\n    export let diverging = false;\n    export let bezier;\n    export let correctLightness;\n\n    export let simulate = 'none';\n    export let steps;\n\n    $: even = numColors % 2 === 0;\n\n    $: numColorsLeft = diverging ? Math.ceil(numColors/2) + (even?1:0) : numColors;\n    $: numColorsRight = diverging ? Math.ceil(numColors/2) + (even?1:0) : 0;\n\n    $: genColors = colors.length !== 1 ? colors : autoColors(colors[0], numColorsLeft);\n    $: genColors2 = colors2.length !== 1 ? colors2 : autoColors(colors2[0], numColorsRight, true);\n\n    $: stepsLeft = colors.length ? chroma.scale(bezier && genColors.length>1 && genColors.length<=5 ? chroma.bezier(genColors) : genColors)\n        .correctLightness(correctLightness)\n        .colors(numColorsLeft) : [];\n\n    $: stepsRight = diverging && colors2.length ? chroma.scale(bezier&& genColors2.length>1 &&genColors2.length<=5 ? chroma.bezier(genColors2) : genColors2)\n        .correctLightness(correctLightness)\n        .colors(numColorsRight) : [];\n\n    $: steps = (even && diverging ? stepsLeft.slice(0, stepsLeft.length-1) : stepsLeft).concat(stepsRight.slice(1));\n\n    function autoGradient(color, numColors) {\n        const lab = chroma(color).lab();\n        const lRange = 100 * (0.95 - 1/numColors);\n        const lStep = lRange / (numColors-1);\n        let lStart = (100-lRange)*0.5;\n        const range = _range(lStart, lStart+numColors*lStep, lStep);\n        let offset = 0;\n        if (!diverging) {\n            offset = 9999;\n            for (let i=0; i < numColors; i++) {\n                let diff = lab[0] - range[i];\n                if (Math.abs(diff) < Math.abs(offset)) {\n                    offset = diff;\n                }\n            }\n        }\n        return range.map(l => chroma.lab([l + offset, lab[1], lab[2]]));\n    }\n\n    function autoColors(color, numColors, reverse=false) {\n        if (diverging) {\n            const colors = autoGradient(color, 3).concat(chroma('#f5f5f5'));\n            if (reverse) colors.reverse();\n            return colors;\n        } else {\n            return autoGradient(color, numColors);\n        }\n    }\n</script>\n\n<style>\n    .palette {\n        background: #eee;\n        padding: 10px;\n        display: flex;\n        height: 100px;\n    }\n    .step {\n       height: 100%;\n       display: block;\n       flex-grow: 1;\n    }\n</style>\n\n<div class=\"palette\">\n    {#each steps as step}\n    <div class=\"step\" style=\"background: {simulate === 'none' ? step : colorBlindSim(step, simulate)}\"></div>\n    {/each}\n</div>\n",
    "<script>\n    import { scaleLinear } from 'd3-scale';\n    import { extent } from 'd3-array';\n    import { line, curveStepAfter } from 'd3-shape';\n    import chroma from 'chroma-js';\n\n    let div;\n    let width;\n    $: height = width * 0.7;\n    export let title = '';\n\n    const padding = {\n        left: 30,\n        right: 10,\n        top: 20,\n        bottom: 20\n    };\n\n    export let steps = [];\n    export let mode = 0;\n\n    $: values = mode <= 2 ? steps.map(c => chroma(c).lch()[mode]) : steps.map(c => chroma(c).hsl()[mode-3]);\n    $: values2 = values.concat(values[values.length-1]);\n\n    $: xScale = scaleLinear()\n        .domain([0, steps.length])\n        .range([padding.left, width - padding.right]);\n\n    $: minDomain = mode === 1 ? 80 : 50;\n    let yDomain;\n    $: {\n        yDomain = extent(values);\n        let diff = Math.abs(yDomain[1] - yDomain[0]);\n        if (diff < minDomain) {\n            yDomain[0] -= (minDomain-diff)*0.5;\n            yDomain[1] += (minDomain-diff)*0.5;\n            yDomain = yDomain;\n        }\n    }\n\n    $: yScale = scaleLinear()\n        .domain(yDomain)\n        .nice()\n        .rangeRound([height - padding.bottom, padding.top]);\n\n    $: y0 = yScale.domain()[0];\n    $: y1 = yScale.domain()[1];\n\n    $: lineGen = line().x((v,i) => xScale(i)).y(yScale).curve(curveStepAfter);\n    $: path = lineGen(values2);\n\n\n</script>\n\n<style>\n    h4 {\n        font-size: 1rem;\n    }\n    svg {\n        width: 100%;\n    }\n    path {\n        fill: none;\n        stroke: black;\n        stroke-width: 2;\n    }\n    text {\n        dominant-baseline: central;\n        font-size: 13px;\n        text-anchor: end;\n    }\n    line {\n        fill: none;\n        stroke: #ddd;\n    }\n    line.direct {\n        stroke-width: 2;\n        stroke: #ccc;\n        stroke-dasharray: 6,4;\n    }\n</style>\n\n<div bind:clientWidth={width} style=\"margin-top: 1em\">\n    <h4>{title}</h4>\n    <svg height={height || 50}>\n        {#if values.length}\n            {#each yScale.ticks(6) as y}\n            <text x=\"{padding.left-5}\" y=\"{yScale(y)}\">{y}</text>\n            <line x1=\"{padding.left}\" x2=\"{width-padding.right}\" transform=\"translate(0,{yScale(y)})\" />\n            {/each}\n            <line\n                class=\"direct\"\n                x1=\"{padding.left}\"\n                x2=\"{width-padding.right}\"\n                y1=\"{yScale(values[0])}\"\n                y2=\"{yScale(values[values.length-1])}\" />\n            <path d={path} />\n        {/if}\n    </svg>\n</div>",
    "<script>\n    import { scaleLinear } from 'd3-scale';\n    import { extent } from 'd3-array';\n    import { line, curveStepAfter } from 'd3-shape';\n    import flatten from 'lodash-es/flatten';\n\n    let div;\n    let width;\n    $: height = width * 0.7;\n    export let title = '';\n    export let colors;\n    export let field;\n    export let values;\n\n    const padding = {\n        left: 30,\n        right: 10,\n        top: 20,\n        bottom: 20\n    };\n\n    let xScale;\n    $: {\n        let xDomainMax = (Array.isArray(values) && Array.isArray(values[0]) && values[0].length) || 0;\n        let xDomain = extent([0, xDomainMax])\n        xScale = scaleLinear()\n        .domain(xDomain)\n        .range([padding.left, width - padding.right]);\n    }\n\n    let yDomain;\n    $: {\n        let min = Math.min(...flatten(values).map(v => v[field]));\n        let max = Math.max(...flatten(values).map(v => v[field]));\n        yDomain = extent([min, max]);\n    }\n\n    $: yScale = scaleLinear()\n        .domain(yDomain)\n        .nice()\n        .rangeRound([height - padding.bottom, padding.top]);\n\n    let vv = v => {\n        if(isNaN(v)) return 0;\n        return v;\n    }\n\n    $: lineGen = line().x((v,i) => vv(xScale(i))).y(yScale).curve(curveStepAfter);\n    $: fieldValues = values.map(c => c.map(v => v[field]))\n    $: paths = fieldValues.map(v => lineGen(v.concat(v[v.length-1])));\n</script>\n\n<style>\n    h4 {\n        font-size: 1rem;\n    }\n    svg {\n        width: 100%;\n    }\n    path {\n        fill: none;\n        stroke-width: 2;\n    }\n    text {\n        dominant-baseline: central;\n        font-size: 13px;\n        text-anchor: end;\n    }\n    line {\n        fill: none;\n        stroke: #ddd;\n    }\n    line.direct {\n        stroke-width: 2;\n        stroke: #ccc;\n        stroke-dasharray: 6,4;\n    }\n</style>\n\n<div bind:clientWidth={width} style=\"margin-top: 1em\">\n    <h4>{title}</h4>\n    <svg height={height || 50}>\n        {#if values.length}\n            {#each yScale.ticks(6) as y}\n            <text x=\"{padding.left-5}\" y=\"{yScale(y)}\">{y}</text>\n            {/each}\n            {#each paths as path, i}\n            <path d={path} key={i} stroke={(colors[i] && colors[i].hex()) || \"#000\"} />\n            {/each}\n            <!-- {#each fieldValues as group, i}\n                {#each group as v, j}\n                <ellipse cx={xScale(j)} cy={yScale(v)} rx=\"5\" ry=\"5\" stroke={(colors[i] && colors[i].hex()) || \"#000\"} fill={(colors[i] && colors[i].hex()) || \"#000\"} opacity=\"0.9\" />\n                {/each}\n            {/each} -->\n        {/if}\n    </svg>\n</div>"
  ],
  "names": [],
  "mappings": "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"
}